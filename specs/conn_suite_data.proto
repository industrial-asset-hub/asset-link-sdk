// ------------------------------------------------------------------
// Connectivity Suite Interface Definition
// ------------------------------------------------------------------
//
// Naming convention according:
// https://cloud.google.com/apis/design/naming_convention
//
// ------------------------------------------------------------------

syntax = "proto3";

// Include for using Protobuf-Any
// import "google/protobuf/any.proto";

import "conn_suite_code.proto";

package siemens.connectivitysuite.data.v1;


//===================================================================
// Data Interface Definitions
//===================================================================

// ===========================================
// The Services Definition
//
service DataApi
{   
    // Possible return values
    // - OK
    // - FAILED_PRECONDITION - no connector configuration available
    //
    rpc GetMetadata( GetMetadataRequest ) returns( GetMetadataResponse ) {};
    
    // Possible return values
    // - OK
    // - FAILED_PRECONDITION - no provided datapoint ID is valid
    //
    // If one or more datapoints are rejected, a code is returned for every single datapoint
    // as part of the return structure.
    //
    rpc CreateSubscription( CreateSubscriptionRequest ) returns ( CreateSubscriptionResponse ) {};
    
    // Possible return values
    // - OK
    // - INVALID_ARGUMENT - provided subscription ID is not valid
    // - FAILED_PRECONDITION - no datapoint assigned to this subscription ID
    //
    rpc StartSubscription( StartSubscriptionRequest ) returns ( stream SubscriptionNotification ) {};
    
    // Possible return values
    // - OK
    // - INVALID_ARGUMENT - provided subscription ID is not valid
    //
    rpc StopSubscription( StopSubscriptionRequest ) returns ( StopSubscriptionResponse ) {};
    
    // Possible return values
    // - OK
    // - INVALID_ARGUMENT - provided subscription ID is not valid
    //
    rpc DeleteSubscription( DeleteSubscriptionRequest ) returns ( DeleteSubscriptionResponse ) {};
    
    // Possible return values
    // - OK
    // - FAILED_PRECONDITION - no provided datapoint ID is valid
    //
    // If one or more datapoints are rejected, a code is returned for every single datapoint
    // as part of the return structure.
    //
    rpc Read( ReadRequest ) returns ( ReadResponse ) {};
    
    // Possible return values
    // - OK
    // - FAILED_PRECONDITION - no provided datapoint ID is valid
    //
    // If one or more datapoints are rejected, a code is returned for every single datapoint
    // as part of the return structure.
    //
    rpc Write( WriteRequest ) returns ( WriteResponse ) {};
  }

// ==================================================================
// Metadata Request
//

// ------------------------------------------------------------------
// parameter for requesting metadata 
//
message GetMetadataRequest {
    // Sequence counter for the message
    // Each type of message requires an individual sequence counter
    uint32 message_sequence = 1;
}

message GetMetadataResponse {

    // Sequence counter for the message
    // Each type of message requires an individual sequence counter
    uint32 message_sequence = 1;

    // Array of metadata per connection, i.e. 
    // each connection provides its own 'MetadataConnection' element
    repeated MetadataConnection connections = 3;
}

message MetadataConnection {

    // Name of the connection, e.g. device name
    // Examples: "PLC_1" or "Audio_Input_3"
    string name = 1;

    // Describe type of the connection
    // Examples: "PN", "S7+", "OPC", "Audio", etc.
    string type = 2;

    // Array of data points, i.e. each datapoint provides its own
    // 'MetadataDataPoint' object
    repeated MetadataDataPoint datapoints = 3;
}

message MetadataDataPoint {
    // Name of this data point
    // The scope of this name is the connection. I.e. inside of one connection
    // this name must be unique!  Different connections can contain datapoints with same name.
    string name = 1;

    // ID of this data point
    // The scope of this ID is the driver. I.e. the datapoint IDs are unique for this
    // driver over all its connections! It is not allowed to use the same ID for two 
    // different datatpoints in one driver (connector)
    // The ID "0" is an invalid value which is used to signal any error.
    uint32 id = 2;
   
    // List of all supported datatypes of the Connectivity Suite
    enum DataType {
      // 'undef' might be used as initial value. This is no valid data type
      DT_UNDEF    =  0;

      // Single bit (0 = false; 1 = true)
      DT_BOOL     =  2;

      // 8 bit unsigned integer (UInt8)
      DT_UINT8    =  3; 

      // 8 bit signed integer (Int8)
      DT_INT8     =  4;

      // 16 bit unsigned integer (UInt16)
      DT_UINT16   =  5;

      // 16 bit signed integer (Int16)
      DT_INT16    =  6;

      // 32 bit unsigned integer (UInt32)
      DT_UINT32   =  7;

      // 32 bit signed integer (Int32)
      DT_INT32    =  8;

      // 64 bit unsigned integer (UInt64)
      DT_UINT64   =  9;

      // 64 bit signed integer (Int64)
      DT_INT64    = 10;

      // 32 bit with a range of values as defined in IEC 60559 
      // For the basic single width floating-point format [IEC-61131-3]
      // or IEEE-754 single precision 32 bit floating point.
      DT_FLOAT32  = 11;

      // 64 bit with a range of values as defined in IEC 60559 
      // For the basic double width floating-point format [IEC-61131-3]
      // or IEEE-754 double precision 64 bit floating point.
      DT_FLOAT64  = 12;

      // 64 bit signed integer which represents a duration 
      // in 100 nano-second [0.1 microsec] intervals.
      // I.e. used for IEC 61131 data types (L)TIME and (L)TIME_OF_DAY
      DT_TIMESPAN = 13; 

      // 64 bit unsigned integer which represents the number 
      // of 100 nano-second [0.1 microsec] intervals since January 1, 1601 (UTC). 
      // The range and resolution corresponds the OPC UA binary data type 'DateTime' as defined in part 6.
      // (Windows FILETIME follows this definition as well)
      // I.e. used for IEC 61131 data types (L)DATE and (L)DATE_AND_TIME.
      DT_TIMESTAMP= 14;

      // Variable-length bit string, byte aligned.
      DT_RAW      = 16;

      // Variable-length character string, UTF-8 [RFC-3629] encoding of ISO-10646. 
      // The maximum string length is either system defined (product and/or HMI device specific), 
      // or configured in the Engineering System for HmiTags of data type String.
      DT_STRING   = 17; 
    }

    // datatype of this datapoint
    DataType type = 3;
   
    // Size of the array dimension(s)
    // Examples:
    // [] ( empty ) - scalar value
    // [2]          - 1-dim array with size 2
    // [0]          - 1-dim array with dynamic size, i.e. size is part of payload
    // [2,3]        - 2-dim array with size 2 x 3
    // [2,0]        - 2-dim array with dynamic size 2 x n, i.e. size of 2nd dimension is part of payload    
    repeated int32 array_dimensions = 5;

    // Possible access modes of a datatpoint
    enum AccessModeType {
      AM_UNDEF      =  0;
      AM_READ       =  1; // read-only
      AM_WRITE      =  2; // write-only
      AM_READ_WRITE =  3; // read and write access
    }

    // access mode of this data point
    AccessModeType access_mode = 6;

    // Optional 'sample rate' can be used as compact array format for high speed data.
    // This feature is especially useful for high speed (high frequency) data to
    // drastically reduce the overhead for the timestamp compared to the
    // process data.
    //
    // When the property 'sample_rate' is set, then the interpretation of the
    // datapoint values (array) is changed in the following way:
    //  - The datapoint needs to be an array type.
    //  - The first member of the value-array is sampled at the timestamp of the record.
    //  - The array members 2..n are sampled at aquidistant times with
    //    a time period of '1/sample_rate'.
    //
    // 'sample_rate_value' of '0' is reserved for future usage.
    // In the current version it must be empty (not used) or a postive value.
    //
    // Example:
    //  value[] = [10, 11, 12, 13]
    //  sample_rate = 1000Hz => sample period=1/sample_rate=1/1000Hz=1ms
    //  record timestamp =     2022-02-22T10:00:00.000
    //  value[0]=10 sampled at 2022-02-22T10:00:00.000 (same as record timestamp)
    //  value[1]=11 sampled at 2022-02-22T10:00:00.001 (record timestamp + 1*sample period)
    //  value[2]=12 sampled at 2022-02-22T10:00:00.002 (record timestamp + 2*sample period)
    //  value[3]=13 sampled at 2022-02-22T10:00:00.003 (record timestamp + 3*sample period)
    double sample_rate_value = 7; // in Hz, e.g. 48000, 16000, 0.25, 0.1

    // Possible types (sources) of the current sample rate
    enum SampleRateType {
        // not using sample_rate feature
        SR_NO_SAMPLE_RATE = 0;

        // 'sample_rate_value' specified here in the Metadata
        SR_STATIC_IN_METADATA = 1;

        // sample rate is part of payload 
        // (directly before the respective value, similar to array length 
        //  but as Float64 value and before the array sizes)
        // This is currently not supported!!!
        //SR_DYNAMIC_IN_PAYLOAD = 2;
    }

    // sample rate type of the datapoint
    SampleRateType sample_rate_type = 8;
}


// ==================================================================
// Data Stream (Subscription)
//

// ------------------------------------------------------------------
// parameter for Creating data stream (create subscription)
// 
message CreateSubscriptionRequest {
    // Sequence counter for the message
    // Each type of message requires an individual sequence counter
    uint32 message_sequence = 1;

    // List of requested datapoints as numbers (IDs)
    repeated uint32 datapoint_ids = 2;

    // Requested cycle in [ms]
    // A value of 0 means 'as fast as possible', that means the smallest cycle which
    // is supported by the connector; in the extreme case this means 'immediately' when
    // a connector doesn't have to use cyclic sampling to acquire the value.
    // The connector might respond with a changed value in the 'provided_cycle'
    // of the response when the requested time cannot be exactly fulfilled.
    // Example 1: the client requests a cycle of 20 ms but the smallest supported cycle
    //   of the connector is 100 ms, then the 'provided_cycle' in the response will be 100 ms
    // Example 2: The connector has an internal base cycle of 100 ms, that means it can only fulfil
    //   cycles which are a multiple of that base cycle.
    //   - Client requests 275 ms cycle
    //   - Connector internally uses an 100 ms base cycle
    //   - Connector responses a 'provided_cycle' of 300 ms because this is
    //     the nearest value
    // see CreateSubscriptionResponse.provided_cycle
    uint32 requested_cycle = 3;
}

// ------------------------------------------------------------------
// acknowledgment for requested data stream
// 
message CreateSubscriptionResponse {
    // Sequence counter for the message
    // Each type of message requires an individual sequence counter
    uint32 message_sequence = 1;

    // subscription ID (needed for related messages)
    // This subscription ID must be unique for this Connector.
    uint32 subscription_id = 2;

    // Provided cycle in [ms]
    // The value might differ from the requested one - see comment for 'CreateSubscriptionRequest'
    uint32 provided_cycle = 3;

    // list of rejected datapoints incl. reasons
    // each rejected datapoint leads to an additional 'RejectedDataPointInfo' element
    repeated RejectedDataPointInfo rejected_datapoints = 5;
}

// details for a rejected datapoint
message RejectedDataPointInfo {

    // ID of the rejected datapoint
    uint32 datapoint_id = 1;

    // Developer-facing human-readable error message in English
    string description = 3;

    // Code for the reason to reject this datapoint
    siemens.connectivitysuite.code.v1.Code result_code = 4;
}

// ------------------------------------------------------------------
// Parameter for 'Start Subscription' Request
// 
message StartSubscriptionRequest {
    // Sequence counter for the message
    // Each type of message requires an individual sequence counter
    uint32 message_sequence = 1;

    // Subscription ID provided by 'CreateSubscriptionResponse'
    uint32 subscription_id = 2;
}

// ------------------------------------------------------------------
// Structured 'Subscription Notification' (gRPC server-side streaming)
//
message SubscriptionNotification {
    // Sequence counter for the message
    // NOTE: This message is used for streaming (in comparison to unary calls)
    // This message requires an individual sequence counter for each separate stream!
    // It enables the client to check for loss of messages
    uint32 message_sequence = 1;

    // Timestamp when the processing of the message has started. 
    // 64 bit unsigned integer which represents the number 
    // of 100 nano-second [0.1 microsec] intervals since January 1, 1601 (UTC).
    // (see Connectivity Suite type DT_TIMESTAMP)
    //
    // NOTE - only temporarily for profiling reasons, will later be removed permanently
    fixed64 start_proc_time = 4;

    // timestamp when the message was sent out
    // 64 bit unsigned integer which represents the number 
    // of 100 nano-second [0.1 microsec] intervals since January 1, 1601 (UTC).
    // (see Connectivity Suite type DT_TIMESTAMP)
    fixed64 message_time = 5;

    // Array of groups of datapoint values
    // One group containts the values of a collection of datatpoints with 
    // shared quality and timestamp(s)
    // (see 'DataPointGroup'')
    repeated DataPointGroup groups = 6;
}

// Datapoint values are grouped by 
// quality code and timestamp(s)
message DataPointGroup {

    // array of datapoint IDs provided in this group
    // e.g. 101, 105, 112
    repeated uint32 datapoint_ids = 1;
     
    // Timestamp of this group or 
    // multiple timestamps, when more than value per datapoint is transferred
    //
    // 64 bit unsigned integer which represents the number 
    // of 100 nano-second [0.1 microsec] intervals since January 1, 1601 (UTC).
    // (see Connectivity Suite type DT_TIMESTAMP)
    //
    // Examples:
    // - single value per datapoint
    //   2021-11-10T12:35:04.236435Z
    //
    // - multiple values per datapoint
    //   |-- timestamp 1 -----------| |-- timestamp 2 ----------|
    //   2021-11-10T12:35:04.236435Z, 2021-11-10T12:35:05.236435Z
    repeated fixed64 time_stamps = 4;
    
    // Sequence counter(s) for this group
    // Number of 'record_sequences' must be equal to the number of 
    // 'time_stamps' - this is the number of 'value sets' transfered
    // with this datapoint group.
    // The 'record_sequences' offer an additional possibility to 
    // check completeness of data.
    // The server should continously increasing the record sequence 
    // counter. So the client could check for gaps.
    //
    // Example: 
    // The Server is using an internal limited ring-buffer to 
    // store all recorded data. When the client receives a datapoint 
    // group with a gap, this might indicate a 'ring buffer overflow'
    // on the server side.
    repeated uint32 record_sequences = 5;
    
    // one quality code for complete data of this group
    // The Quality Code is used as described in "OPC Data Access Custom Interface 
    // Specification Version 3.0" chapter "6.8 OPC Quality flags"
    //
    // Meaning |    Flags       | Ext. Sub-Status |Quality| Sub-Status  | Limits|
    // BIT     | 15  14  13  12 |  11  10   9   8 | 7  6  | 5  4  3  2  |  1  0 |
    //
    // Bit 7..6 - Quality
    // - 0 = BAD - the value is not useful
    // - 1 = UNCERTAIN - The quality of the dp value is less than normal, but the value may still be useful
    // - 2 = GOOD (non-cascade) - The quality of the dp value is good
    // - 3 = GOOD (cascade) - The quality of the dp value is good and may be used in control
    uint32 quality = 6;
    
    // Array of raw-data values.
    // Serialised according type information provided by the metadata
    // Details see related 'Connectivity Suite Document'
    //
    // Examples:
    // - single value per datapoint:
    //   <val 101><val 105><val 112>
    //
    // - multiple values per datapoint: 
    //   |-- record 1 -------------||-- record 2 -------------|
    //   <val 101><val 105><val 112><val 101><val 105><val 112>
    //
    // - array value with dynamic size
    //   |size| -- values ------------------ |
    //   | 3  |<val101_1><val101_2><val101_3>|
    bytes payload = 3;
}

// ------------------------------------------------------------------
// Parameter for 'Stop Subscription' Request
// 
message StopSubscriptionRequest {
    // sequence counter for the message
    // Each type of message requires an individual sequence counter
    uint32 message_sequence = 1;

    // Subscription ID provided by 'CreateSubscriptionResponse'
    uint32 subscription_id = 2;
}

// ------------------------------------------------------------------
// response for 'Stop Subscription'
//
message StopSubscriptionResponse {
    // Sequence counter for the message
    // Each type of message requires an individual sequence counter
    uint32 message_sequence = 1;
}

// ------------------------------------------------------------------
// Parameter for 'Delete Subscription' Request
// 
message DeleteSubscriptionRequest {
    // Sequence counter for the message
    // Each type of message requires an individual sequence counter
    uint32 message_sequence = 1;

    // Subscription ID provided by 'CreateSubscriptionResponse'
    uint32 subscription_id = 2;
}

// ------------------------------------------------------------------
// response for 'Delete Subscription'
//
message DeleteSubscriptionResponse {
    // Sequence counter for the message
    // Each type of message requires an individual sequence counter
    uint32 message_sequence = 1;
}

// ------------------------------------------------------------------
// Request for 'Read'
// 
message ReadRequest {
    // Sequence counter for the message
    // Each type of message requires an individual sequence counter
    uint32 message_sequence = 1;

    // list of requested datapoints as numbers (IDs)
    // IDs must correspond to the 'GetMetadataResponse'
    repeated uint32 datapoint_ids = 2;
}

// ------------------------------------------------------------------
// Response for 'Read'
// 
message ReadResponse {
    // Sequence counter for the message
    // Each type of message requires an individual sequence counter
    uint32 message_sequence = 1;

    // timestamp when the message was sent out
    // 64 bit unsigned integer which represents the number 
    // of 100 nano-second [0.1 microsec] intervals since January 1, 1601 (UTC).
    // (see Connectivity Suite type DT_TIMESTAMP)
    fixed64 message_time = 2;

    // array of variable groups
    repeated ReadDataPointGroup groups = 3;

    // list of rejected datapoints incl. error codes
    // each rejected datapoint leads to an additional 'RejectedDataPointInfo' element
    repeated RejectedDataPointInfo rejected_datapoints = 4;
}

message ReadDataPointGroup {
    // timestamp of this group of datapoints
    // 64 bit unsigned integer which represents the number 
    // of 100 nano-second [0.1 microsec] intervals since January 1, 1601 (UTC).
    // (see Connectivity Suite type DT_TIMESTAMP)
    fixed64 time = 1;

    // quality code of all members of this datapoint group
    // (details see comments for 'DataPointGroup.quality')
    uint32 quality = 2;

    // array of variable IDs provided in this group
    repeated uint32 datapoint_ids = 3;

    // array of raw-data
    // (details see comments for 'DataPointGroup.payload')
    bytes payload = 4;
}

// ------------------------------------------------------------------
// Request for 'Write'
// 
message WriteRequest {
    // Sequence counter for the message
    // Each type of message requires an individual sequence counter
    uint32 message_sequence = 1;

    // list of provided datapoints as numbers (IDs)
    // IDs must correspond to the 'GetMetadataResponse'
    repeated uint32 datapoint_ids = 2;

    // value(s)
    // (details see comments for 'DataPointGroup.payload')
    bytes payload = 3;
}

// ------------------------------------------------------------------
// Response for 'Write'
// 
message WriteResponse {
    // Sequence counter for the message
    // Each type of message requires an individual sequence counter
    uint32 message_sequence = 1;

    // list of rejected datapoints incl. reasons
    // each rejected datapoint leads to an additional 'RejectedDataPointInfo' element
    repeated RejectedDataPointInfo rejected_datapoints = 2;
}